<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/index.xml</link>
    <description>Recent content on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Thu, 09 Feb 2017 12:45:22 -0500</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>monojee</title>
      <link>https://networknt.github.io/light-java/design/monojee/</link>
      <pubDate>Thu, 09 Feb 2017 12:45:22 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/monojee/</guid>
      <description></description>
    </item>
    
    <item>
      <title>newprod</title>
      <link>https://networknt.github.io/light-java/design/newprod/</link>
      <pubDate>Thu, 09 Feb 2017 12:45:08 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/newprod/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Convert WebServices to Microservices</title>
      <link>https://networknt.github.io/light-java/design/convtws/</link>
      <pubDate>Thu, 09 Feb 2017 10:59:44 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/convtws/</guid>
      <description>&lt;p&gt;While you are talking about microservices, chances are you existing application
is built as web services. These days a lot of people and vendors are calling
these web services as microservices and it is not right.&lt;/p&gt;

&lt;p&gt;The following diagram shows what is the difference between web service
and microservices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/web_micro_service.jpeg&#34; alt=&#34;web_micro_service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see the traditional web servers are flattened behind an API gateway
and they are normally build on top of Java EE platform with JAXRS 1.1 or 2.0&lt;/p&gt;

&lt;p&gt;In essence, each web service is still a big monolithic Java EE application and
does everything in a war or ear file. Although they expose RESTful API but they
are not microservices.&lt;/p&gt;

&lt;p&gt;On the right side, the same payment API is broken up to microservices and the
payment API in the picture acts as a facade API which has static ip address and
can be accessed from F5 (or other reverse proxy and load balancer) directly.
Unlike the webservice does everything in the same application, the microservice
payment API will call customer service to get customer info, get account service
to check the balance, call risk service to make sure there is no money laundry
risk, verify if the customer has the right to do the transaction with auth
service. And then call the transfer service to move fund from one account to
another. If the two accounts are in different currency, then the currency
exchange service will be called to convert currency from on to another.&lt;/p&gt;

&lt;p&gt;As you can see, the network communication in microservice diagram is significant
more then web service and this is why that traditional commercial API gateway
is not suitable in this architecture as it will become bottleneck and single
point of failure. Most gateway products on the market today are Java EE based
monolithic application and it is against distributed principal of microservices
architecture.&lt;/p&gt;

&lt;p&gt;Microservice architecture evolves from monolithic application architecture
naturally as a monolith grows to certain stage that become not maintainable
and not scalable. Imaging that you have a big application and only one
developer knows it inside out and every time one line of code is changed ten
other places are broken. The make every release risky and there are several
months testing cycles to ensure that nothing is broken. In order to meet the
demand from business growth, the application can only be scaled horizontally
and it is all or nothing. You cannot scale an individual service which is
facing volume spike during month end and year end.&lt;/p&gt;

&lt;p&gt;From anohter perspective, it is natual for human beings to break up complex
things into simpler and smaller pieces to tackle it. This is not just limited
to computer software but in every field. According to brain science, most
people can only remember 7 to 9 things in short term and focus on them
at a particular moment. Can you imagine a big application with thousands
moving pieces? A good developer/prgrammer must have very good short term
memory so that their brain can wire many things together.&lt;/p&gt;

&lt;p&gt;IIn the entire history of software programming, developers were break things
up all the time. If you ever worked on assembly in early years, you know it
is a big monolithic app with one entry point and so many goto statements.
some smart developers tried to extract common and repeatable code into function
so that it can be called from different places.&lt;/p&gt;

&lt;p&gt;A monolithic application just like a Java class with only one main method with
thousands line of code. In order to make it easy to read and maintain, some of
the duplicated lines of code should be extracted into other method in the same
class or some other classes. This make developers&amp;rsquo; life easier becuase when
you work, you are dealing with only one class or one method at a time. The only
problem with this kind of break up is classes and methods are tightly coupled
and there are a lot of assumptions in these class and method calls. This is
why you change one method to fix an issue for one caller and other callers are
broken as they have different assumptions although the signaure of the method
has never been changed. Another issue with this kind of break up is you have to
package your changed method/class with others as one deployment unit to deploy
them together to production and the entire deployment process is very risky.&lt;/p&gt;

&lt;p&gt;Microservices just go to the next step, instead of separate methods or classes
calling in-process. We make these reusable pieces as inter-process services
revoked through HTTP. The benefit is you can update/replace individual service
independently without impacting the entire application. As these service are
very small, they are easier to be implemented and maintained by developers.&lt;/p&gt;

&lt;p&gt;Unlike class or method calls, calling microservices over the network is very
slow. So it is unwise to break an application to thousands pieces and every
request will have to go through 50 to 100 network hops to get it done. The
network latency will kill the performance no mater how you scale your services.&lt;/p&gt;

&lt;p&gt;whenever possible, the calls to other services should be done in parallel so
that the slowest service will decide the response time. If you call multiple
services in serial, then the sum of these services will be your response time.&lt;/p&gt;

&lt;p&gt;Given above nature of microservices, a low latency HTTP server is very important
so that it won&amp;rsquo;t add to much over head to each service to service call. Also,
as service calls are over the network, there are a lot of things need to be
handled like security, logging, metrics, auditing, service registry/discovery
etc. This is why you need a framework to build microservices so that developers
can only focus on the business logic of the service without worrying about
cross-cutting concerns. The light-java/light-java-rest framework is designed
just for that.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>https://networknt.github.io/light-java/design/</link>
      <pubDate>Thu, 09 Feb 2017 10:57:47 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/</guid>
      <description>&lt;p&gt;light-java is aiming microservices and design of microservices is more art other
than technique. When you break a business application to smaller pieces, there
is a threshold. If it too fine-grained, then the performance will suffer, but
if it is too coarse-grained, then the benefit of microservices will be diminishing.&lt;/p&gt;

&lt;p&gt;The big portion of design work for microservices is to functionally divide an
application to multiple services and define the communication contract between
these services with OpenAPI specifications.&lt;/p&gt;

&lt;p&gt;Here is a list of design decisions for microservices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/convtws/&#34;&gt;How to convert existing RESTful web services to microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/newprod/&#34;&gt;How to design microservices for brand new project/product&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/monojee/&#34;&gt;How to replace monolithic Java EE application to microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Request and Response Dump</title>
      <link>https://networknt.github.io/light-java/middleware/dump/</link>
      <pubDate>Mon, 06 Feb 2017 21:40:01 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/dump/</guid>
      <description>&lt;p&gt;This is a handler that dumps the entire request and response into a log file. It
should only be used in development mode for debugging purpose as it is very slow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://networknt.github.io/light-java/other/zookeeper/</link>
      <pubDate>Mon, 06 Feb 2017 21:34:10 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/zookeeper/</guid>
      <description>&lt;p&gt;A Zookeeper registry implementation that use Zookeeper as registry and discovery
server. It implements both registry and discovery in the same module for
Zookeeper communication. If the API/server is delivered as docker image, another
product called registrator will be used to register it with Zookeeper server.
Otherwise, the server module will be responsible to register itself during
startup.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Switcher</title>
      <link>https://networknt.github.io/light-java/other/switcher/</link>
      <pubDate>Mon, 06 Feb 2017 21:34:02 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/switcher/</guid>
      <description>&lt;p&gt;This module implement a switch and its notifier to support on/off
state within the system.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service</title>
      <link>https://networknt.github.io/light-java/other/service/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:54 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/service/</guid>
      <description>&lt;p&gt;A light-weight and fast dependency injection framework without any third
party dependencies.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Registry</title>
      <link>https://networknt.github.io/light-java/other/registry/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:47 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/registry/</guid>
      <description>&lt;p&gt;This module contains all the interfaces that are needed in registry and
discovery. Also it implemented Direct registry which you can hard-code
services into the service.json in order to simulate consul or zookeeper
during development.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Health Check</title>
      <link>https://networknt.github.io/light-java/other/health/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:38 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/health/</guid>
      <description>&lt;p&gt;This is an handler that needs to be injected into the request/response chain
in order to return something that indicate the server is still alive. Currently
it returns &amp;ldquo;OK&amp;rdquo; only.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handler</title>
      <link>https://networknt.github.io/light-java/other/handler/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:25 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/handler/</guid>
      <description>&lt;p&gt;This module defines an interface that all middleware handlers must be implemented
in order to be loaded during server startup.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface MiddlewareHandler extends HttpHandler {

    HttpHandler getNext();

    MiddlewareHandler setNext(final HttpHandler next);

    boolean isEnabled();

    void register();

}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Consul</title>
      <link>https://networknt.github.io/light-java/other/consul/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:14 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/consul/</guid>
      <description>&lt;p&gt;A consul registry implementation that use Consul as registry and discovery
server. It implements both registry and discovery in the same module for
consul communication. If the API/server is delivered as docker image, another
product called registrator will be used to register it with Consul agent.
Otherwise, the server module will be responsible to register itself during
startup.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cluster</title>
      <link>https://networknt.github.io/light-java/other/cluster/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:04 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/cluster/</guid>
      <description>&lt;p&gt;This module caches all the service instances that are needed by the current
service and calling underline registry(Direct, Consul and ZooKeeper) to
discover the service if necessary (first time a service is called and registry
notifies something has been changed regarding to subscribe the services on
Consul or ZooKeeper).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Load Balance</title>
      <link>https://networknt.github.io/light-java/other/balance/</link>
      <pubDate>Mon, 06 Feb 2017 21:32:51 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/balance/</guid>
      <description>&lt;p&gt;Client side discovery needs client side load balancer in order to pick
up one and only one available service instance to a particular request.&lt;/p&gt;

&lt;p&gt;Currently, only Round-Robin is supported and other implementations will
follow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Correlation Id</title>
      <link>https://networknt.github.io/light-java/middleware/correlation/</link>
      <pubDate>Mon, 06 Feb 2017 09:59:28 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/correlation/</guid>
      <description>

&lt;p&gt;This is a handler that checks if X-Correlation-Id exists in request header. If it doesn&amp;rsquo;t exist
it will generate a UUID and put it into the request header. During API to API calls, this header
will be passed to the next API by Client module.&lt;/p&gt;

&lt;h1 id=&#34;generating&#34;&gt;Generating&lt;/h1&gt;

&lt;p&gt;The correlationId is very useful in microservices architecture as there are multiple services
involved in a same client request. When logs are aggregated into a centralized tool, it is
very important there is an unique identifier to associate logs from multiple services for the
same request. The Id is an UUID and must be generated in the first service called from client.&lt;/p&gt;

&lt;h1 id=&#34;passing&#34;&gt;Passing&lt;/h1&gt;

&lt;p&gt;Since the first service generates the Id, it must be passed to other services somehow so that
subsequent services can use it to log their messages. In our &lt;a href=&#34;https://networknt.github.io/light-java/other/client/&#34;&gt;client&lt;/a&gt;
module, it passes the correlationId from the current request header to the request to the next
service.&lt;/p&gt;

&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;

&lt;p&gt;This handler gets the X-Correlation-Id from request header or generate one if it doesn&amp;rsquo;t
exist in the request header. After that, it puts it into the org.slf4j.MDC so that logback
can put it into the log for every logging statement.&lt;/p&gt;

&lt;h1 id=&#34;logback-xml&#34;&gt;logback.xml&lt;/h1&gt;

&lt;p&gt;In the generated logback.xml, the cId is part of the appender config as pattern &amp;ldquo;%X{cId}&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;appender name=&amp;quot;stdout&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %X{cId} %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;appender name=&amp;quot;log&amp;quot; class=&amp;quot;ch.qos.logback.core.FileAppender&amp;quot;&amp;gt;
        &amp;lt;File&amp;gt;target/test.log&amp;lt;/File&amp;gt;
        &amp;lt;Append&amp;gt;false&amp;lt;/Append&amp;gt;
        &amp;lt;layout class=&amp;quot;ch.qos.logback.classic.PatternLayout&amp;quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %X{cId} %-5level %class{36}:%L %M - %msg%n&amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>