<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/index.xml</link>
    <description>Recent content on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Sat, 18 Mar 2017 20:37:48 -0400</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Minikube Installation</title>
      <link>https://networknt.github.io/light-java/tools/minikube/</link>
      <pubDate>Sat, 18 Mar 2017 20:37:48 -0400</pubDate>
      
      <guid>https://networknt.github.io/light-java/tools/minikube/</guid>
      <description>

&lt;p&gt;As light-java API/service is aiming to deployed with Docker containers and
Kubernetes is the most popular container orchestration tool. It is very hard
to setup multiple nodes cluster on laptop development environment but there
is a minikube can be used on laptop to create one node cluster on your laptop.&lt;/p&gt;

&lt;h2 id=&#34;install-on-mac&#34;&gt;Install on Mac.&lt;/h2&gt;

&lt;h3 id=&#34;install-xhype&#34;&gt;Install xhype&lt;/h3&gt;

&lt;p&gt;Before installing Minikube, you must install &lt;a href=&#34;https://github.com/zchee/docker-machine-driver-xhyve#install&#34;&gt;xhype&lt;/a&gt;
driver first. The detailed instructions are in the above link and here is the
commands to be executed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install docker-machine-driver-xhyve
sudo chown root:wheel $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve
sudo chmod u+s $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-minikube&#34;&gt;Install minikube&lt;/h3&gt;

&lt;p&gt;The general installation guide is in the &lt;a href=&#34;https://github.com/kubernetes/minikube&#34;&gt;README&lt;/a&gt;
and the latest instruction is always specific for the latest release. The current
release instruction can be found &lt;a href=&#34;https://github.com/kubernetes/minikube/releases&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.17.1/minikube-darwin-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-kubectl&#34;&gt;Install kubectl&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl
chmod +x ./kubectl
sudo mv ./kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;start-minikube&#34;&gt;Start minikube&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;minikube start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-on-linux&#34;&gt;Install on Linux&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Rate Limiting</title>
      <link>https://networknt.github.io/light-java/middleware/limit/</link>
      <pubDate>Fri, 17 Feb 2017 14:10:28 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/limit/</guid>
      <description>

&lt;p&gt;Although our framework can handle potential millions requests per second, for
some public facing APIs, it might be a good idea to enable this handler to
limit the concurrent request to certain level in order to avoid DDOS attacks.&lt;/p&gt;

&lt;p&gt;As this handler will impact the overall performance a little bit, it is not
configured as default in the swagger-codegen. You must manually enable it
in your API with the following steps.&lt;/p&gt;

&lt;h2 id=&#34;dependency&#34;&gt;Dependency&lt;/h2&gt;

&lt;p&gt;In order to use this handler, the following dependency need to be added to
pom.xml in your project.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;limit&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;

&lt;p&gt;As this middleware is not plugged in by default, we need to add it into
com.networknt.handler.MiddlewareHandler in src/main/resources/META-INF/services
folder. As this rate limiting handler needs to be failed fast, it need to be
put right after ExceptionHandler and MetricsHandler. The reason it is after
MetricsHandler is to capture 513 error code in InfluxDB and Grafana for
monitoring on production.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Traceability Put traceabilityId into response header from request header if it exists
com.networknt.traceability.TraceabilityHandler
#Rate Limiting
com.networknt.limit.LimitHandler
#Metrics In order to calculate response time accurately, this needs to be the second.
com.networknt.metrics.MetricsHandler
#Exception Global exception handler that needs to be called first.
com.networknt.exception.ExceptionHandler

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;config&#34;&gt;Config&lt;/h2&gt;

&lt;p&gt;Here is the configuration file for rate limiting.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Rate Limit Handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: false,
  &amp;quot;concurrentRequest&amp;quot;: 1000,
  &amp;quot;queueSize&amp;quot;: -1
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;enabled true to enable it and false to disable it.&lt;/li&gt;
&lt;li&gt;concurrentRequest number of concurrent request to be limited.&lt;/li&gt;
&lt;li&gt;queueSize -1 unlimited queue size which might use a lot of memory. &amp;gt; 1 integer will limit the requests to be queued and once queue is full, 513 will be returned for new requests.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Cross-Origin Resource Sharing</title>
      <link>https://networknt.github.io/light-java/tutorials/cors/</link>
      <pubDate>Wed, 15 Feb 2017 09:26:58 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/tutorials/cors/</guid>
      <description>&lt;p&gt;For some of the APIs/services, the endpoints will be accessed from a Single Page
Application(React/Vue/Angular) served from another domain. In this case, the API
server needs to handle the pre-flight OPTIONS request to enable CORS.&lt;/p&gt;

&lt;p&gt;As CORS only used in above scenario, the handler is not wired in by default in
swagger-codegen.&lt;/p&gt;

&lt;p&gt;If you want to limit only several domains for CORS, you also need to create cors.json
in config folder.&lt;/p&gt;

&lt;p&gt;And here is an example of cors.json&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;description&amp;quot;: &amp;quot;Cors Http Handler&amp;quot;,
  &amp;quot;enabled&amp;quot;: true,
  &amp;quot;allowedOrigins&amp;quot;: [
    &amp;quot;http://localhost&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To enable CORS support, you need to add cors module in pom.xml, you need to update
pom.xml to add a dependency.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.networknt&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cors&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${version.light-java}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update com.networknt.handler.MiddlewareHandler in src/main/resources/META-INF/services
folder to plug cors handler into the middleware chain. Note that cors handler is in front
of swagger so that pre-flight OPTIONS request will be returned before swagger validation
is done as OPTIONS methods are not defined in swagger specifitions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This file is generated and should not be changed unless you want to plug in more handlers into the handler chain
# for cross cutting concerns. In most cases, you should replace some of the default handlers with your own implementation
# Please note: the sequence of these handlers are very important.

#Validator Validate request based on swagger specification (depending on Swagger and Body)
com.networknt.validator.ValidatorHandler
#Sanitizer Encode cross site scripting
com.networknt.sanitizer.SanitizerHandler
#SimpleAudit Log important info about the request into audit log
com.networknt.audit.AuditHandler
#Body Parse body based on content type in the header.
com.networknt.body.BodyHandler
#Security JWT token verification and scope verification (depending on SwaggerHandler)
com.networknt.security.JwtVerifyHandler
#Swagger Parsing swagger specification based on request uri and method.
com.networknt.swagger.SwaggerHandler
#Cors handler to handler post/put pre-flight
com.networknt.cors.CorsHttpHandler
#Correlation Create correlationId if it doesn&#39;t exist in the request header and put it into the request header
com.networknt.correlation.CorrelationHandler
#Traceability Put traceabilityId into response header from request header if it exists
com.networknt.traceability.TraceabilityHandler
#Metrics In order to calculate response time accurately, this needs to be the second.
com.networknt.metrics.MetricsHandler
#Exception Global exception handler that needs to be called first.
com.networknt.exception.ExceptionHandler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s start the server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/networknt/light-java-example/cors
mvn clean install exec:exec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test the pre-flight OPTIONS.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Origin: http://example.com&amp;quot; -H &amp;quot;Access-Control-Request-Method: POST&amp;quot;  -H &amp;quot;Access-Control-Request-Headers: X-Requested-With&amp;quot;  -X OPTIONS --verbose http://localhost:8080/v1/postData
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the result&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8080 (#0)
&amp;gt; OPTIONS /v1/postData HTTP/1.1
&amp;gt; Host: localhost:8080
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt; Origin: http://example.com
&amp;gt; Access-Control-Request-Method: POST
&amp;gt; Access-Control-Request-Headers: X-Requested-With
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Access-Control-Allow-Headers: X-Requested-With
&amp;lt; Server: Light
&amp;lt; Access-Control-Allow-Credentials: true
&amp;lt; Content-Length: 0
&amp;lt; Access-Control-Allow-Methods: POST
&amp;lt; Access-Control-Max-Age: 3600
&amp;lt; Date: Wed, 15 Feb 2017 13:37:29 GMT
&amp;lt; 
* Connection #0 to host localhost left intact

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The source code for the cors example can be found at&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/networknt/light-java-example/tree/master/cors&#34;&gt;https://github.com/networknt/light-java-example/tree/master/cors&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>monojee</title>
      <link>https://networknt.github.io/light-java/design/monojee/</link>
      <pubDate>Thu, 09 Feb 2017 12:45:22 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/monojee/</guid>
      <description></description>
    </item>
    
    <item>
      <title>newprod</title>
      <link>https://networknt.github.io/light-java/design/newprod/</link>
      <pubDate>Thu, 09 Feb 2017 12:45:08 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/newprod/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Convert WebServices to Microservices</title>
      <link>https://networknt.github.io/light-java/design/convtws/</link>
      <pubDate>Thu, 09 Feb 2017 10:59:44 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/convtws/</guid>
      <description>&lt;p&gt;While you are talking about microservices, chances are you existing application
is built as web services. These days a lot of people and vendors are calling
these web services as microservices and it is not right.&lt;/p&gt;

&lt;p&gt;The following diagram shows what is the difference between web service
and microservices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/web_micro_service.jpeg&#34; alt=&#34;web_micro_service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see the traditional web servers are flattened behind an API gateway
and they are normally build on top of Java EE platform with JAXRS 1.1 or 2.0&lt;/p&gt;

&lt;p&gt;In essence, each web service is still a big monolithic Java EE application and
does everything in a war or ear file. Although they expose RESTful API but they
are not microservices.&lt;/p&gt;

&lt;p&gt;On the right side, the same payment API is broken up to microservices and the
payment API in the picture acts as a facade API which has static ip address and
can be accessed from F5 (or other reverse proxy and load balancer) directly.
Unlike the webservice does everything in the same application, the microservice
payment API will call customer service to get customer info, get account service
to check the balance, call risk service to make sure there is no money laundry
risk, verify if the customer has the right to do the transaction with auth
service. And then call the transfer service to move fund from one account to
another. If the two accounts are in different currency, then the currency
exchange service will be called to convert currency from on to another.&lt;/p&gt;

&lt;p&gt;As you can see, the network communication in microservice diagram is significant
more then web service and this is why that traditional commercial API gateway
is not suitable in this architecture as it will become bottleneck and single
point of failure. Most gateway products on the market today are Java EE based
monolithic application and it is against distributed principal of microservices
architecture.&lt;/p&gt;

&lt;p&gt;Microservice architecture evolves from monolithic application architecture
naturally as a monolith grows to certain stage that become not maintainable
and not scalable. Imaging that you have a big application and only one
developer knows it inside out and every time one line of code is changed ten
other places are broken. The make every release risky and there are several
months testing cycles to ensure that nothing is broken. In order to meet the
demand from business growth, the application can only be scaled horizontally
and it is all or nothing. You cannot scale an individual service which is
facing volume spike during month end and year end.&lt;/p&gt;

&lt;p&gt;From anohter perspective, it is natual for human beings to break up complex
things into simpler and smaller pieces to tackle it. This is not just limited
to computer software but in every field. According to brain science, most
people can only remember 7 to 9 things in short term and focus on them
at a particular moment. Can you imagine a big application with thousands
moving pieces? A good developer/prgrammer must have very good short term
memory so that their brain can wire many things together.&lt;/p&gt;

&lt;p&gt;IIn the entire history of software programming, developers were break things
up all the time. If you ever worked on assembly in early years, you know it
is a big monolithic app with one entry point and so many goto statements.
some smart developers tried to extract common and repeatable code into function
so that it can be called from different places.&lt;/p&gt;

&lt;p&gt;A monolithic application just like a Java class with only one main method with
thousands line of code. In order to make it easy to read and maintain, some of
the duplicated lines of code should be extracted into other method in the same
class or some other classes. This make developers&amp;rsquo; life easier becuase when
you work, you are dealing with only one class or one method at a time. The only
problem with this kind of break up is classes and methods are tightly coupled
and there are a lot of assumptions in these class and method calls. This is
why you change one method to fix an issue for one caller and other callers are
broken as they have different assumptions although the signaure of the method
has never been changed. Another issue with this kind of break up is you have to
package your changed method/class with others as one deployment unit to deploy
them together to production and the entire deployment process is very risky.&lt;/p&gt;

&lt;p&gt;Microservices just go to the next step, instead of separate methods or classes
calling in-process. We make these reusable pieces as inter-process services
revoked through HTTP. The benefit is you can update/replace individual service
independently without impacting the entire application. As these service are
very small, they are easier to be implemented and maintained by developers.&lt;/p&gt;

&lt;p&gt;Unlike class or method calls, calling microservices over the network is very
slow. So it is unwise to break an application to thousands pieces and every
request will have to go through 50 to 100 network hops to get it done. The
network latency will kill the performance no mater how you scale your services.&lt;/p&gt;

&lt;p&gt;whenever possible, the calls to other services should be done in parallel so
that the slowest service will decide the response time. If you call multiple
services in serial, then the sum of these services will be your response time.&lt;/p&gt;

&lt;p&gt;Given above nature of microservices, a low latency HTTP server is very important
so that it won&amp;rsquo;t add to much over head to each service to service call. Also,
as service calls are over the network, there are a lot of things need to be
handled like security, logging, metrics, auditing, service registry/discovery
etc. This is why you need a framework to build microservices so that developers
can only focus on the business logic of the service without worrying about
cross-cutting concerns. The light-java/light-java-rest framework is designed
just for that.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>https://networknt.github.io/light-java/design/</link>
      <pubDate>Thu, 09 Feb 2017 10:57:47 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/</guid>
      <description>&lt;p&gt;light-java is aiming microservices and design of microservices is more art other
than technique. When you break a business application to smaller pieces, there
is a threshold. If it too fine-grained, then the performance will suffer, but
if it is too coarse-grained, then the benefit of microservices will be diminishing.&lt;/p&gt;

&lt;p&gt;The big portion of design work for microservices is to functionally divide an
application to multiple services and define the communication contract between
these services with OpenAPI specifications.&lt;/p&gt;

&lt;p&gt;Here is a list of design decisions for microservices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://blog.arungupta.me/microservice-design-patterns/&#34;&gt;Microservice Design Patterns&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/convtws/&#34;&gt;How to convert existing RESTful web services to microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/newprod/&#34;&gt;How to design microservices for brand new project/product&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/monojee/&#34;&gt;How to replace monolithic Java EE application to microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Request and Response Dump</title>
      <link>https://networknt.github.io/light-java/middleware/dump/</link>
      <pubDate>Mon, 06 Feb 2017 21:40:01 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/dump/</guid>
      <description>&lt;p&gt;This is a handler that dumps the entire request and response into a log file. It
should only be used in development mode for debugging purpose as it is very slow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://networknt.github.io/light-java/other/zookeeper/</link>
      <pubDate>Mon, 06 Feb 2017 21:34:10 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/zookeeper/</guid>
      <description>&lt;p&gt;A Zookeeper registry implementation that use Zookeeper as registry and discovery
server. It implements both registry and discovery in the same module for
Zookeeper communication. If the API/server is delivered as docker image, another
product called registrator will be used to register it with Zookeeper server.
Otherwise, the server module will be responsible to register itself during
startup.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Switcher</title>
      <link>https://networknt.github.io/light-java/other/switcher/</link>
      <pubDate>Mon, 06 Feb 2017 21:34:02 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/switcher/</guid>
      <description>&lt;p&gt;This module implement a switch and its notifier to support on/off
state within the system.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service</title>
      <link>https://networknt.github.io/light-java/other/service/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:54 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/service/</guid>
      <description>&lt;p&gt;A light-weight and fast dependency injection framework without any third
party dependencies.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Registry</title>
      <link>https://networknt.github.io/light-java/other/registry/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:47 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/registry/</guid>
      <description>&lt;p&gt;This module contains all the interfaces that are needed in registry and
discovery. Also it implemented Direct registry which you can hard-code
services into the service.json in order to simulate consul or zookeeper
during development.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Health Check</title>
      <link>https://networknt.github.io/light-java/other/health/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:38 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/health/</guid>
      <description>&lt;p&gt;This is an handler that needs to be injected into the request/response chain
in order to return something that indicate the server is still alive. Currently
it returns &amp;ldquo;OK&amp;rdquo; only.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handler</title>
      <link>https://networknt.github.io/light-java/other/handler/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:25 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/handler/</guid>
      <description>&lt;p&gt;This module defines an interface that all middleware handlers must be implemented
in order to be loaded during server startup.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface MiddlewareHandler extends HttpHandler {

    HttpHandler getNext();

    MiddlewareHandler setNext(final HttpHandler next);

    boolean isEnabled();

    void register();

}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Consul</title>
      <link>https://networknt.github.io/light-java/other/consul/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:14 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/consul/</guid>
      <description>&lt;p&gt;A consul registry implementation that use Consul as registry and discovery
server. It implements both registry and discovery in the same module for
consul communication. If the API/server is delivered as docker image, another
product called registrator will be used to register it with Consul agent.
Otherwise, the server module will be responsible to register itself during
startup.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>