<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Light Java - The fastest Java API Framework</title>
    <link>https://networknt.github.io/light-java/index.xml</link>
    <description>Recent content on Light Java - The fastest Java API Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Thu, 09 Feb 2017 12:45:22 -0500</lastBuildDate>
    <atom:link href="https://networknt.github.io/light-java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>monojee</title>
      <link>https://networknt.github.io/light-java/design/monojee/</link>
      <pubDate>Thu, 09 Feb 2017 12:45:22 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/monojee/</guid>
      <description></description>
    </item>
    
    <item>
      <title>newprod</title>
      <link>https://networknt.github.io/light-java/design/newprod/</link>
      <pubDate>Thu, 09 Feb 2017 12:45:08 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/newprod/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Convert WebServices to Microservices</title>
      <link>https://networknt.github.io/light-java/design/convtws/</link>
      <pubDate>Thu, 09 Feb 2017 10:59:44 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/convtws/</guid>
      <description>&lt;p&gt;While you are talking about microservices, chances are you existing application
is built as web services. These days a lot of people and vendors are calling
these web services as microservices and it is not right.&lt;/p&gt;

&lt;p&gt;The following diagram shows what is the difference between web service
and microservices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://networknt.github.io/light-java/images/web_micro_service.jpeg&#34; alt=&#34;web_micro_service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see the traditional web servers are flattened behind an API gateway
and they are normally build on top of Java EE platform with JAXRS 1.1 or 2.0&lt;/p&gt;

&lt;p&gt;In essence, each web service is still a big monolithic Java EE application and
does everything in a war or ear file. Although they expose RESTful API but they
are not microservices.&lt;/p&gt;

&lt;p&gt;On the right side, the same payment API is broken up to microservices and the
payment API in the picture acts as a facade API which has static ip address and
can be accessed from F5 (or other reverse proxy and load balancer) directly.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>https://networknt.github.io/light-java/design/</link>
      <pubDate>Thu, 09 Feb 2017 10:57:47 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/design/</guid>
      <description>&lt;p&gt;light-java is aiming microservices and design of microservices is more art other
than technique. When you break a business application to smaller pieces, there
is a threshold. If it too fine-grained, then the performance will suffer, but
if it is too coarse-grained, then the benefit of microservices will be diminishing.&lt;/p&gt;

&lt;p&gt;The big portion of design work for microservices is to functionally divide an
application to multiple services and define the communication contract between
these services with OpenAPI specifications.&lt;/p&gt;

&lt;p&gt;Here is a list of design decisions for microservices:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/convtws/&#34;&gt;How to convert existing RESTful web services to microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/newprod/&#34;&gt;How to design microservices for brand new project/product&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://networknt.github.io/light-java/design/monojee/&#34;&gt;How to replace monolithic Java EE application to microservices&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Request and Response Dump</title>
      <link>https://networknt.github.io/light-java/middleware/dump/</link>
      <pubDate>Mon, 06 Feb 2017 21:40:01 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/dump/</guid>
      <description>&lt;p&gt;This is a handler that dumps the entire request and response into a log file. It
should only be used in development mode for debugging purpose as it is very slow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zookeeper</title>
      <link>https://networknt.github.io/light-java/other/zookeeper/</link>
      <pubDate>Mon, 06 Feb 2017 21:34:10 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/zookeeper/</guid>
      <description>&lt;p&gt;A Zookeeper registry implementation that use Zookeeper as registry and discovery
server. It implements both registry and discovery in the same module for
Zookeeper communication. If the API/server is delivered as docker image, another
product called registrator will be used to register it with Zookeeper server.
Otherwise, the server module will be responsible to register itself during
startup.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Switcher</title>
      <link>https://networknt.github.io/light-java/other/switcher/</link>
      <pubDate>Mon, 06 Feb 2017 21:34:02 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/switcher/</guid>
      <description>&lt;p&gt;This module implement a switch and its notifier to support on/off
state within the system.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Service</title>
      <link>https://networknt.github.io/light-java/other/service/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:54 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/service/</guid>
      <description>&lt;p&gt;A light-weight and fast dependency injection framework without any third
party dependencies.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Registry</title>
      <link>https://networknt.github.io/light-java/other/registry/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:47 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/registry/</guid>
      <description>&lt;p&gt;This module contains all the interfaces that are needed in registry and
discovery. Also it implemented Direct registry which you can hard-code
services into the service.json in order to simulate consul or zookeeper
during development.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Health Check</title>
      <link>https://networknt.github.io/light-java/other/health/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:38 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/health/</guid>
      <description>&lt;p&gt;This is an handler that needs to be injected into the request/response chain
in order to return something that indicate the server is still alive. Currently
it returns &amp;ldquo;OK&amp;rdquo; only.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handler</title>
      <link>https://networknt.github.io/light-java/other/handler/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:25 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/handler/</guid>
      <description>&lt;p&gt;This module defines an interface that all middleware handlers must be implemented
in order to be loaded during server startup.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface MiddlewareHandler extends HttpHandler {

    HttpHandler getNext();

    MiddlewareHandler setNext(final HttpHandler next);

    boolean isEnabled();

    void register();

}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Consul</title>
      <link>https://networknt.github.io/light-java/other/consul/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:14 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/consul/</guid>
      <description>&lt;p&gt;A consul registry implementation that use Consul as registry and discovery
server. It implements both registry and discovery in the same module for
consul communication. If the API/server is delivered as docker image, another
product called registrator will be used to register it with Consul agent.
Otherwise, the server module will be responsible to register itself during
startup.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cluster</title>
      <link>https://networknt.github.io/light-java/other/cluster/</link>
      <pubDate>Mon, 06 Feb 2017 21:33:04 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/cluster/</guid>
      <description>&lt;p&gt;This module caches all the service instances that are needed by the current
service and calling underline registry(Direct, Consul and ZooKeeper) to
discover the service if necessary (first time a service is called and registry
notifies something has been changed regarding to subscribe the services on
Consul or ZooKeeper).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Load Balance</title>
      <link>https://networknt.github.io/light-java/other/balance/</link>
      <pubDate>Mon, 06 Feb 2017 21:32:51 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/other/balance/</guid>
      <description>&lt;p&gt;Client side discovery needs client side load balancer in order to pick
up one and only one available service instance to a particular request.&lt;/p&gt;

&lt;p&gt;Currently, only Round-Robin is supported and other implementations will
follow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Correlation Id</title>
      <link>https://networknt.github.io/light-java/middleware/correlation/</link>
      <pubDate>Mon, 06 Feb 2017 09:59:28 -0500</pubDate>
      
      <guid>https://networknt.github.io/light-java/middleware/correlation/</guid>
      <description>

&lt;p&gt;This is a handler that checks if X-Correlation-Id exists in request header. If it doesn&amp;rsquo;t exist
it will generate a UUID and put it into the request header. During API to API calls, this header
will be passed to the next API by Client module.&lt;/p&gt;

&lt;h1 id=&#34;generating&#34;&gt;Generating&lt;/h1&gt;

&lt;p&gt;The correlationId is very useful in microservices architecture as there are multiple services
involved in a same client request. When logs are aggregated into a centralized tool, it is
very important there is an unique identifier to associate logs from multiple services for the
same request. The Id is an UUID and must be generated in the first service called from client.&lt;/p&gt;

&lt;h1 id=&#34;passing&#34;&gt;Passing&lt;/h1&gt;

&lt;p&gt;Since the first service generates the Id, it must be passed to other services somehow so that
subsequent services can use it to log their messages. In our &lt;a href=&#34;https://networknt.github.io/light-java/other/client/&#34;&gt;client&lt;/a&gt;
module, it passes the correlationId from the current request header to the request to the next
service.&lt;/p&gt;

&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;

&lt;p&gt;This handler gets the X-Correlation-Id from request header or generate one if it doesn&amp;rsquo;t
exist in the request header. After that, it puts it into the org.slf4j.MDC so that logback
can put it into the log for every logging statement.&lt;/p&gt;

&lt;h1 id=&#34;logback-xml&#34;&gt;logback.xml&lt;/h1&gt;

&lt;p&gt;In the generated logback.xml, the cId is part of the appender config as pattern &amp;ldquo;%X{cId}&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;appender name=&amp;quot;stdout&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
        &amp;lt;!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %X{cId} %-5level %logger{36} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;appender name=&amp;quot;log&amp;quot; class=&amp;quot;ch.qos.logback.core.FileAppender&amp;quot;&amp;gt;
        &amp;lt;File&amp;gt;target/test.log&amp;lt;/File&amp;gt;
        &amp;lt;Append&amp;gt;false&amp;lt;/Append&amp;gt;
        &amp;lt;layout class=&amp;quot;ch.qos.logback.classic.PatternLayout&amp;quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;%d{HH:mm:ss.SSS} [%thread] %X{cId} %-5level %class{36}:%L %M - %msg%n&amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>